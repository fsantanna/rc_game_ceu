//*** #include's are no longer necessary

//*** SDL_Rect -> Rect
code/tight Collision (var Rect r1, var Rect r2) -> bool
do
  if r1.x+r1.w < r2.x then
    escape false;
  end
  if r1.y+r1.h < r2.y then
    escape false;
  end
  if r2.x+r2.w < r1.x then
    escape false;
  end
  if r2.y+ r2.h < r1.y then
    escape false;
  end
  escape true;
end

//*** "ren" arguments are no longer necessary
code/await Ship (var int x, var int y) -> (var Rect rect, var int velx, var int vely, event bool collided) -> FOREVER do
  rect = val Rect(x, y, 48, 60);      //*** TODO: GRAPHICS_GET_BMP_DIMENSIONS
  var bool is_green = true;
  var bool recently_collided = false;
  var bool right_is_down = false;
  var bool left_is_down = false;
  var bool up_is_down = false;
  var bool down_is_down = false;
  velx = 0;
  vely = 0;

  par do
    var int key;                  //*** payload is now an int
    every key in KEY_PRESS do     //*** SDL_KEYDOWN -> KEY_PRESS
      if key == KEY_RIGHT then    //*** _SDLK_* -> KEY_*
        right_is_down = true;
      end
      if key == KEY_LEFT then
        left_is_down = true;
      end
      if key == KEY_UP then
        up_is_down = true;
      end
      if key == KEY_DOWN then
        down_is_down = true;
      end
    end

  with
    var int key;
    every key in KEY_UNPRESS do   //*** SDL_KEYUP -> KEY_UNPRESS
      if key == KEY_RIGHT then
        right_is_down = false;
      end
      if key == KEY_LEFT then
        left_is_down = false;
      end
      if key == KEY_UP then
        up_is_down = false;
      end
      if key == KEY_DOWN then
        down_is_down = false;
      end
    end

  with
    every 50ms do
      if right_is_down then
        velx = velx + 1;
      end
      if left_is_down then
        velx = velx - 1;
      end
      if down_is_down then        //*** Y-axis is (un)inverted
        vely = vely - 1;
      end
      if up_is_down then          //*** Y-axis is (un)inverted
        vely = vely + 1;
      end

      var int new_x = rect.x + velx;
      var int new_y = rect.y + vely;

      if new_x < -400+rect.w/2 then
        new_x = -400+rect.w/2;    //*** positions are center relative
      end
      if new_x > 400-rect.w/2 then
        new_x = 400-rect.w/2;
      end
      if new_y < -240+rect.h/2 then
        new_y = -240+rect.h/2;
      end
      if new_y > 240-rect.h/2 then
        new_y = 240-rect.h/2;
      end

      velx = new_x - rect.x;
      vely = new_y - rect.y;

      rect.x = new_x;
      rect.y = new_y;

    end
  with
    every FRAMES_REDRAW do
      emit GRAPHICS_DRAW_BMP(rect.x,rect.y, "logo-ship.bmp");   //*** pass path directly (currently no cache, possibly very slow)
      if recently_collided then
        if is_green then
          emit GRAPHICS_DRAW_BMP(rect.x,rect.y, "logo-green-overlay.bmp");
        else
          emit GRAPHICS_DRAW_BMP(rect.x,rect.y, "logo-red-overlay.bmp");
        end
      end
    end
  with
    loop do
      if recently_collided then
        //
      else
        is_green = await collided;
        recently_collided = true;
      end
      par/or do
        is_green = await collided;
        recently_collided = true;
      with
        await 1s;
        recently_collided = false;
      end
    end
  end
end

code/await Test_Case (var Rect rect, var Color c) -> (var Rect rct, event void collided) -> void do
  rct = val Rect(rect.x, rect.y, _rand() % 2 * 40 + 40, 40);
  var int speed = _rand() % 4 + 4;

  par/or do
    await collided;
  with
    every 50ms do
      rct.x = rct.x - speed;
      if rct.x < -420 then
        break;
      end
    end
  with
    every FRAMES_REDRAW do
        emit GRAPHICS_SET_COLOR_RGB(c.r,c.g,c.b);           //*** SDL_SetRenderDrawColor -> GRAPHICS_SET_COLOR_RGB
        emit GRAPHICS_DRAW_RECT(rct.x,rct.y, rct.w,rct.h);  //*** SDL_RenderFillRect -> GRAPHICS_DRAW_RECT
    end
  end
end

code/await Green (var Rect rect) -> (var& Rect rct, event& void collided) -> void do
  var&? Test_Case tst = spawn Test_Case(rect, Color(0x99,0xFF,0x99));
  watching tst do
    rct = &tst.rct;             // bind my public fields to corresponding fields in Test_Case
    collided = &tst.collided;
    await FOREVER;              // nothing else to do, behave just like Test_Case
  end
end

code/await Red (var Rect rect) -> (var& Rect rct, event& void collided) -> void do
  var&? Test_Case tst = spawn Test_Case(rect, Color(0xFF,0x99,0x99));
  watching tst do
    rct = &tst.rct;
    collided = &tst.collided;
    await FOREVER;
  end
end

code/await Particle (var Rect rect, var int ship_velx, var int ship_vely, var Color c) -> void do
  var int velx = _rand() % 6 - 3 + ship_velx;
  var int vely = _rand() % 6 - 3 + ship_vely;

  par/or do
    every 250ms do
      if rect.w > 1 then
        rect.w = rect.w - 1;
        rect.h = rect.h - 1;
      else
        break;
      end
    end
  with
    every 50ms do
      if rect.x > -400+rect.w/2 and rect.x < 400-rect.w/2 and rect.y > -240+rect.h/2 and rect.y < 240-rect.h/2 then
        rect.x = rect.x + velx;
        rect.y = rect.y + vely;
      else
        break;
      end
    end
  with
    every FRAMES_REDRAW do
      emit GRAPHICS_SET_COLOR_RGB(c.r, c.g, c.b);
      emit GRAPHICS_DRAW_RECT(rect.x,rect.y, rect.w,rect.h);    //*** TODO: GRAPHICS_DRAW_CIRCLE
    end
  end
end

code/await Score (void) -> (event void collided_green, event void collided_red) -> void do
  var int recentgreens = 0;
  var int recentreds = 0;

  par do
    every collided_green do
      recentgreens = recentgreens + 1;
    end
  with
    every collided_red do
      recentreds = recentreds + 1;
    end
  with
    await 10s;
    every 1s do
      if recentgreens > 0 then
        recentgreens = recentgreens - 1;
      else/if recentreds > 0 then
        recentreds = recentreds - 1;
      else
        break;
      end
    end
  with
    every FRAMES_REDRAW do
      var int i;
      loop i in [0->10[ do
        var Rect placement_circle = val Rect(200 + i*14, 50, 10,10);
        if i < recentgreens then
          emit GRAPHICS_SET_COLOR_NAME(COLOR_GREEN);
        else/if i < recentgreens + recentreds then
          emit GRAPHICS_SET_COLOR_NAME(COLOR_RED);
        else
          emit GRAPHICS_SET_COLOR_NAME(COLOR_GRAY);
        end
        emit GRAPHICS_DRAW_RECT(-195+i*14,185, 10,10);
      end
    end
  end
end

//*** SDL_Init -> WINDOW_SET_TITLE/SET_SIZE
emit WINDOW_SET_TITLE("Red/Green Recurse/Center");
emit WINDOW_SET_SIZE(800,480,800,480);

loop do
  // show splash screen
  emit GRAPHICS_DRAW_BMP(0,0, "splash.bmp");        //*** (0,0) is the screen center, x grows to left, y grows to top
  await KEY_PRESS;

  emit WINDOW_SET_CLEAR_COLOR_RGB(0xFF,0xFF,0xFF);  //*** background color on FPS mode
  emit FRAMES_SET(yes);                             //*** switch to FPS mode

  var&? Score score = spawn Score();

  watching score do
    pool[20] Green gs;
    pool[20] Red rs;

    par do
      every 40ms do
        spawn Green(Rect((_rand() % 800) + 400, -240 + _rand() % 480, 40,40)) in gs;
        spawn Red(Rect((_rand() % 800) + 400, -240 + _rand() % 480, 40,40)) in rs;
      end

    with
      var& Ship ship = spawn Ship(-300, 0);
      pool[] Particle ps;
      every FRAMES_UPDATE do    //*** SDL_DT -> FRAMES_UPDATE
        var&? Green green;
        loop green in gs do
          if (call Collision(ship.rect, green!.rct)) then
            emit green!.collided;
            emit ship.collided(true);
            emit score.collided_green;
            emit SOUND_PLAY("tele_toneup.wav");   //*** _Mix_PlayChannel -> SOUND_PLAY
            var int i;
            var int num_particles = _rand() % 25 + 10;
            loop i in [0->num_particles[ do
              var int sq = _rand() % 10 + 8;
              spawn Particle(Rect(green!.rct.x, green!.rct.y, sq, sq), ship.velx, ship.vely, Color(0x99, 0xFF, 0x99)) in ps;
            end
          end
        end
        var&? Red red;
        loop red in rs do
          if (call Collision(ship.rect, red!.rct)) then
            emit red!.collided;
            emit ship.collided(false);
            emit score.collided_red;
            emit SOUND_PLAY("tele_tonedown.wav");
            var int i;
            var int num_particles = _rand() % 25 + 10;
            loop i in [0->num_particles[ do
              var int sq = _rand() % 10 + 8;
              spawn Particle(Rect(red!.rct.x, red!.rct.y, sq, sq), ship.velx, ship.vely, Color(0xFF, 0x99, 0x99)) in ps;
            end
          end
        end
      end
    end
  end

  // show lose screen
  emit FRAMES_SET(no);                      // switch to immediate mode
  emit GRAPHICS_DRAW_BMP(0,0, "lose.bmp");
  await 1s;
  await KEY_PRESS;
end   // loop

escape 0;
